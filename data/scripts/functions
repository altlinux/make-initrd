#!/bin/sh

message() {
	logger --socket-errors=off -s -t "initrd${stage:+: $stage}" "$*"
}

error() {
	message "ERROR: $*"
}

debug() {
	[ -z "$DEBUG" ] || message "$@"
}

verbose() {
	[ -n "$QUIET" ] || message "$@"
}

makenod() {
	[ -e /dev/$1 ] || mknod /dev/$1 $2 $3 $4
}

modprobe_check() {
	local s
	for s in /scripts/kmodules/*check-"$1"; do
		if [ -x "$s" ]; then
			"$s" || return 0
		fi
	done
	modprobe -q "$1"
}

shell() {
	# Disallow console access
	[ "$PANIC" != 0 ] || reboot

	if [ -n "$RESCUE_MODULES" ]; then
		local kmod
		for kmod in $RESCUE_MODULES; do
			modprobe_check "$kmod"
		done
	fi

	run_scripts 'pre/shell'

	[ "$#" -eq 0 ] || message "$@"
	message "This shell remains here for debug purposes. Press Ctrl-D to continue."
	PS1='(initramfs) ' /bin/sh -i +m

	run_scripts 'post/shell'
}

run_module() {
	local stage
	export stage="$1"
	shift
	run "$@"
}

run_scripts() {
	local s
	for s in /scripts/all/* /scripts/"$1"/*; do
		[ -x "$s" ] || continue
		verbose "Running $s ..."
		. "$s"
	done
}

load_modules() {
	local m
	[ ! -e /etc/initrd/modules-"$1" ] ||
	while read m; do
		[ -n "${m##\#*}" ] || continue
		modprobe_check "$m"
	done < /etc/initrd/modules-"$1"
}

glob() {
	local q=
	[ "$1" != '-q' ] ||
		{ q=1; shift; }
	[ -e "$1" ] ||
		return 1
	[ -n "$q" ] ||
		printf '%s\n' "$@"
}

mk_event() {
	mktemp "$udev_eventdir/$1.XXXXXXXXX"
}

done_event() {
	mv -f "$1" "${1%/*}/done.${1##*/}"
}

remove_done_events() {
	rm -f "$1/done."* 2>/dev/null
}

omit_pid() {
	printf '%s\n' "$@" >> "$omitproc"
}

devlinks_check() {
	local l
	for l in $DEVLINKS; do
		[ "$1" != "$l" ] ||
			return 0
	done
	return 1
}

get_dev() {
	local name retval value

	if [ "$#" = 2 ]; then
		retval="$1"; shift
	fi
	name="$1"; shift

	case "$name" in
		'')
			return 1
			;;
		UUID=*)
			[ "$ID_FS_UUID" = "${name#UUID=}" ] ||
				return 1
			;;
		LABEL=*)
			[ "$ID_FS_LABEL" = "${name#LABEL=}" ] ||
				return 1
			;;
		/dev/disk/by-uuid/*)
			[ "/dev/disk/by-uuid/$ID_FS_UUID_ENC" = "$name" ] ||
				return 1
			;;
		/dev/disk/by-label/*)
			[ "/dev/disk/by-label/$ID_FS_LABEL_ENC" = "$name" ] ||
				return 1
			;;
		/dev/block/[0-9]*:[0-9]*)
			[ "/dev/block/$MAJOR:$MINOR" = "$name" ] ||
				return 1
			;;
		/*)
			[ "$DEVNAME" = "$name" ] || devlinks_check "$name" ||
				return 1
			;;
		*:*)
			[ "$MAJOR" = "${name%:*}" -a "$MINOR" = "${name#*:}" ] ||
				return 1
			;;
		*)
			value=$(( 0x$name ))
			[ "$MAJOR" = "$(( $value / 256 ))" -a "$MINOR" = "$(( $value % 256 ))" ] ||
				return 1
			;;
	esac
	[ -z "$retval" ] ||
		eval "$retval=\"\$DEVNAME\""
}
